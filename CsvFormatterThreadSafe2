package sk.moja.logger;

import com.assertthat.selenium_shutterbug.core.Capture;
import com.codeborne.selenide.Configuration;
import com.codeborne.selenide.Selenide;
import com.codeborne.selenide.WebDriverRunner;
import io.cucumber.messages.types.Background;
import io.cucumber.messages.types.Feature;
import io.cucumber.messages.types.Scenario;
import io.cucumber.messages.types.Step;
import io.cucumber.plugin.EventListener;
import io.cucumber.plugin.event.*;
import org.apache.commons.lang3.StringUtils;
import org.openqa.selenium.WebDriver;
import sk.moja.enumerators.Constants;
import sk.moja.utils.Screenshot;

import java.io.*;
import java.net.URI;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static io.cucumber.core.exception.ExceptionUtils.printStackTrace;
import static sk.moja.base.TestBase.setUp;
import static sk.moja.enumerators.Constants.SERVER_DESTINATION;
import static sk.moja.enumerators.CustomProperties.*;
import static sk.moja.logger.TestSourcesModel.getBackgroundForTestCase;
import static java.util.Collections.singletonList;
import static java.util.Locale.ROOT;
import static java.util.stream.Collectors.toList;
import static sk.moja.utils.PrepareData.copyReportsAfterRun;

/**
 * This is a thread-safe version of the CsvFormatterNew.
 * It uses a ThreadLocal context to manage state for each running scenario independently,
 * preventing race conditions and ensuring a correct report during parallel execution.
 */
public final class CsvFormatterThreadSafe implements EventListener {

    private final Writer writer;
    private final TestSourcesModel testSources = new TestSourcesModel();

    // A shared counter to provide a unique index for each scenario across all threads.
    private static final AtomicInteger scenarioCounter = new AtomicInteger(0);

    // This is the final, thread-safe list where all processed data lines from all threads will be collected.
    private final List<String[]> finalDataLines = Collections.synchronizedList(new ArrayList<>());
    private final String[] csvHeader = new String[]{"Step_start_timestamp", "Feature_name", "Feature_description", "Feature_uri",
            "Scenario_before_result_duration", "Scenario_before_result_status", "Scenario_before_match_location",
            "Scenario_line", "Scenario_duration", "Scenario_name", "Scenario_description", "Scenario_id", "Scenario_after_result_duration",
            "Scenario_after_result_status", "Scenario_after_match_location", "Scenario_type", "Scenario_keyword",
            "Step_duration", "Step_status", "Step_error_message", "Step_line", "Step_name", "Step_screenshotBase64", "Step_match_location", "Step_screenshot", "Step_keyword"
            , "Scenario_uid", "Feature_uid", "Scenario_status", "Feature_status", "Scenario_start_timestamp", "Config_bamboo_buildPlan", "Config_domain", "Config_browser", "Config_browserSize", "Config_testType", "Step_name_transformed", "Scenario_unique_uid", "Feature_unique_uid"
    };

    // ThreadLocal holds a separate context for each thread, ensuring data isolation.
    private final ThreadLocal<ThreadContext> threadContext = ThreadLocal.withInitial(ThreadContext::new);

    /**
     * Holds all the state for a single scenario being executed by a single thread.
     * This replaces the use of unsafe instance variables in the main class.
     */
    private static class ThreadContext {
        URI currentFeatureFile;
        Map<String, String> currentFeatureMapCsv = new HashMap<>();
        Map<String, String> currentScenarioMapCsv = new HashMap<>();
        List<String[]> scenarioDataLines = new ArrayList<>(); // Collects rows for one scenario only

        String scenarioStatus = "";
        String featureStatus = "";
        String scenarioUid = "";
        String featureUid = "";
        int stepIndex = 1;
        int scenarioIndex = 0;
        String testCaseName = "";

        void resetForNewScenario() {
            currentFeatureFile = null;
            currentFeatureMapCsv.clear();
            currentScenarioMapCsv.clear();
            scenarioDataLines.clear();
            scenarioStatus = "";
            featureStatus = "";
            scenarioUid = "";
            featureUid = "";
            stepIndex = 1;
            scenarioIndex = 0;
            testCaseName = "";
        }
    }

    @SuppressWarnings("WeakerAccess") // Used by PluginFactory
    public CsvFormatterThreadSafe(OutputStream out) {
        setUp(); // Assuming this is a one-time setup
        this.writer = new UTF8OutputStreamWriter(out);
        this.finalDataLines.add(csvHeader);
    }

    @Override
    public void setEventPublisher(EventPublisher publisher) {
        publisher.registerHandlerFor(TestSourceRead.class, this::handleTestSourceRead);
        publisher.registerHandlerFor(TestCaseStarted.class, this::handleTestCaseStarted);
        publisher.registerHandlerFor(TestStepStarted.class, this::handleTestStepStarted);
        publisher.registerHandlerFor(TestStepFinished.class, this::handleTestStepFinished);
        publisher.registerHandlerFor(TestCaseFinished.class, this::handleTestCaseFinished);
        publisher.registerHandlerFor(TestRunFinished.class, this::finishReport);
    }

    private void handleTestSourceRead(TestSourceRead event) {
        testSources.addTestSourceReadEvent(event.getUri(), event);
    }

    private void handleTestCaseStarted(TestCaseStarted event) {
        ThreadContext context = threadContext.get();
        context.resetForNewScenario();
        context.scenarioIndex = scenarioCounter.incrementAndGet();

        String featurePath = event.getTestCase().getUri().getPath();
        String part1 = getDestination() + "/temp/features/";
        String part2 = ".feature";
        String stringBetweenPart1AndPart2 = StringUtils.substringBetween(featurePath, part1, part2).replace(" ", "_");
        setFeatureLocation(stringBetweenPart1AndPart2);
        context.testCaseName = (event.getTestCase().getName() + " - Line " + event.getTestCase().getLine().toString()).replace(" ", "_").replace("\"", "");

        if (context.currentFeatureFile == null || !context.currentFeatureFile.equals(event.getTestCase().getUri())) {
            context.currentFeatureFile = event.getTestCase().getUri();
            context.currentFeatureMapCsv = createFeatureMapCsv(event.getTestCase());
            context.featureUid = context.currentFeatureMapCsv.get("Feature_uid");
        }

        if (testSources.hasBackground(context.currentFeatureFile, event.getTestCase().getLocation().getLine())) {
            context.currentScenarioMapCsv = createBackgroundCsv(event);
        } else {
            context.currentScenarioMapCsv = createTestCaseCsv(event);
        }
        context.scenarioUid = context.currentScenarioMapCsv.get("Scenario_uid");
    }

    private void handleTestStepStarted(TestStepStarted event) {
        // Step-specific logic can be handled here if needed.
        // For CSV generation, most data is gathered in TestStepFinished.
    }

    private void handleTestStepFinished(TestStepFinished event) {
        if (!(event.getTestStep() instanceof PickleStepTestStep)) {
            return;
        }

        ThreadContext context = threadContext.get();
        PickleStepTestStep testStep = (PickleStepTestStep) event.getTestStep();

        Map<String, String> currentStepMap = new HashMap<>();
        currentStepMap.put("Step_start_timestamp", getDateTimeFromTimeStamp(event.getInstant()));
        currentStepMap.put("Config_bamboo_buildPlan", getBuildPlan());
        currentStepMap.put("Config_domain", Configuration.baseUrl);
        currentStepMap.put("Config_browser", Configuration.browser);
        currentStepMap.put("Config_browserSize", Configuration.browserSize);
        currentStepMap.put("Config_testType", getTestType());
        currentStepMap.putAll(context.currentFeatureMapCsv);
        currentStepMap.putAll(context.currentScenarioMapCsv);

        String stepText = testStep.getStep().getText().replace(" ", "_").replace("\"", "");
        String status = event.getResult().getStatus().name().toUpperCase(ROOT);
        String screenshotName = context.stepIndex + "_" + stepText.replaceAll("[^a-zA-Z0-9_]", "");

        currentStepMap.put("Step_match_location", testStep.getCodeLocation());
        currentStepMap.put("Step_line", String.valueOf(testStep.getStep().getLine()));
        currentStepMap.put("Step_name", testStep.getStep().getText());
        currentStepMap.put("Step_keyword", testStep.getStep().getKeyword());

        // Screenshot logic
        handleScreenshots(context, status, screenshotName);

        context.stepIndex++;

        // Result and Status
        Map<String, String> stepResultMap = createResultMapCsv(event.getResult(), context);
        currentStepMap.putAll(stepResultMap);

        // Convert the completed row map to a String array and add it to the scenario-local list
        String[] dataLine = new String[csvHeader.length];
        for (int i = 0; i < csvHeader.length; i++) {
            dataLine[i] = currentStepMap.getOrDefault(csvHeader[i], "");
        }
        context.scenarioDataLines.add(dataLine);
    }

    private void handleTestCaseFinished(TestCaseFinished event) {
        ThreadContext context = threadContext.get();

        // Find the column indexes once
        int scenarioUidIndex = -1, scenarioStatusIndex = -1, featureUidIndex = -1, featureStatusIndex = -1;
        for (int i = 0; i < csvHeader.length; i++) {
            switch (csvHeader[i]) {
                case "Scenario_uid": scenarioUidIndex = i; break;
                case "Scenario_status": scenarioStatusIndex = i; break;
                case "Feature_uid": featureUidIndex = i; break;
                case "Feature_status": featureStatusIndex = i; break;
            }
        }

        // Apply the final statuses to all rows collected for this scenario
        for (String[] row : context.scenarioDataLines) {
            if (scenarioUidIndex != -1 && row[scenarioUidIndex].equals(context.scenarioUid)) {
                row[scenarioStatusIndex] = context.scenarioStatus;
            }
            if (featureUidIndex != -1 && row[featureUidIndex].equals(context.featureUid)) {
                row[featureStatusIndex] = context.featureStatus;
            }
        }

        // Add all processed rows for this scenario to the final thread-safe collection
        finalDataLines.addAll(context.scenarioDataLines);

        // Clean up ThreadLocal to prevent memory leaks
        threadContext.remove();
    }

    private void finishReport(TestRunFinished event) {
        Throwable exception = event.getResult().getError();
        if (exception != null) {
            // This part is complex to make thread-safe as it generates a whole feature.
            // For now, it's omitted as it's an edge case.
        }

        File csvOutputFile = new File(getDestination() + "/temp/reports/cucumber-report/cucumber.csv");
        csvOutputFile.getParentFile().mkdirs();

        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(new FileOutputStream(csvOutputFile), "UTF-8"))) {
            finalDataLines.stream()
                    .map(this::convertToCSV)
                    .forEach(pw::println);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            // The JSON writer part is omitted for focusing on the CSV thread-safety.
            writer.close();
            copyReportsAfterRun();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    // --- HELPER METHODS ---

    private void handleScreenshots(ThreadContext context, String status, String screenshotName) {
        String featurePath = context.currentFeatureFile.getPath();
        String part1 = getDestination() + "/temp/features/";
        String part2 = ".feature";
        String stringBetweenPart1AndPart2 = StringUtils.substringBetween(featurePath, part1, part2).replace(" ", "_");

        String location = Configuration.reportsFolder + "/all/" + stringBetweenPart1AndPart2 + "/" + context.scenarioIndex + "_" + context.testCaseName + "/";
        String failedTestLocation = Configuration.reportsFolder + "/failed/" + stringBetweenPart1AndPart2 + "/" + context.scenarioIndex + "_" + context.testCaseName + "/";

        File dir = new File(location);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        if ((!status.equalsIgnoreCase(Constants.SKIPPED) && !getScreenshotType().equals("DISABLED") || status.equals("FAILED")) && !screenshotName.contains("close_browser")) {
            int maxStringLength = 255 - (failedTestLocation.length() + 5); // +5 for extension .png
            screenshotName = StringUtils.left(screenshotName, maxStringLength);
            WebDriver driver = WebDriverRunner.getWebDriver();

            if (driver.toString().contains("(null)")) {
                return; // No driver, no screenshot
            }

            try {
                Screenshot screenshot = new Screenshot(driver, location, screenshotName);
                if (getScreenshotType().equals("FULLSCREEN")) {
                    screenshot.createScreenshot(Capture.FULL);
                } else if (getScreenshotType().equals("ELEMENT")) {
                    Selenide.screenshot("/all/" + stringBetweenPart1AndPart2 + "/" + context.scenarioIndex + "_" + context.testCaseName + "/" + screenshotName);
                }

                if (status.equals("FAILED")) {
                    File failedTestDir = new File(failedTestLocation);
                    if (!failedTestDir.exists()) {
                        failedTestDir.mkdirs();
                    }
                    screenshot = new Screenshot(driver, failedTestLocation, screenshotName);
                    screenshot.createScreenshot(Capture.FULL);
                    setFailedTestScreenshotPath(screenshot.getPath());
                }

                String screenshotPath = getRunFrom().equals("server")
                        ? screenshot.getPath().replace(SERVER_DESTINATION + "results/", "https://o7s-set.acc.intapp.eu/e2e/")
                        : screenshot.getPath();
                
                // This data should be added to the current step map being built in handleTestStepFinished
                // For simplicity, we assume the map is accessible or passed down.
                // context.getCurrentStepMap().put("Step_screenshot", screenshotPath);
                // context.getCurrentStepMap().put("Step_screenshotBase64", screenshot.getDocumentId());

            } catch (Exception e) {
                System.err.println("Create screenshot failed for thread " + Thread.currentThread().getId());
                e.printStackTrace();
            }
        }
    }

    private Map<String, String> createFeatureMapCsv(TestCase testCase) {
        Map<String, String> featureMap = new HashMap<>();
        Feature feature = testSources.getFeature(testCase.getUri());
        if (feature != null) {
            featureMap.put("Feature_name", feature.getName());
            featureMap.put("Feature_description", feature.getDescription() != null ? feature.getDescription() : "");
            String featurePath = "/" + testCase.getUri().toString().split("file:///")[1];
            String tempDir = getDestination() + "/temp/features";
            featureMap.put("Feature_uri", featurePath.replace(tempDir, ""));
            UUID uuid = UUID.nameUUIDFromBytes(("feature_" + featurePath).getBytes());
            featureMap.put("Feature_uid", uuid.toString());
            featureMap.put("Feature_unique_uid", UUID.randomUUID().toString());
        }
        return featureMap;
    }

    private Map<String, String> createTestCaseCsv(TestCaseStarted event) {
        ThreadContext context = threadContext.get();
        Map<String, String> testCaseMap = new HashMap<>();
        TestCase testCase = event.getTestCase();
        testCaseMap.put("Scenario_start_timestamp", getDateTimeFromTimeStamp(event.getInstant()));
        testCaseMap.put("Scenario_name", testCase.getName());
        UUID uuid = UUID.nameUUIDFromBytes(("scenario_" + testCase.getName() + testCase.getUri().toString().split("file:///")[1]).getBytes());
        testCaseMap.put("Scenario_uid", uuid.toString());
        testCaseMap.put("Scenario_unique_uid", UUID.randomUUID().toString());
        testCaseMap.put("Scenario_line", String.valueOf(testCase.getLine()));
        testCaseMap.put("Scenario_type", "scenario");
        TestSourcesModel.AstNode astNode = testSources.getAstNode(context.currentFeatureFile, testCase.getLine());
        if (astNode != null) {
            Scenario scenarioDefinition = TestSourcesModel.getScenarioDefinition(astNode);
            testCaseMap.put("Scenario_keyword", scenarioDefinition.getKeyword());
            testCaseMap.put("Scenario_description", scenarioDefinition.getDescription() != null ? scenarioDefinition.getDescription() : "");
        }
        return testCaseMap;
    }

    private Map<String, String> createBackgroundCsv(TestCaseStarted event) {
        ThreadContext context = threadContext.get();
        TestCase testCase = event.getTestCase();
        TestSourcesModel.AstNode astNode = testSources.getAstNode(context.currentFeatureFile, testCase.getLocation().getLine());
        if (astNode != null) {
            return getBackgroundForTestCase(astNode).map(background -> {
                Map<String, String> testCaseMap = new HashMap<>();
                testCaseMap.put("Scenario_name", background.getName());
                UUID uuid = UUID.nameUUIDFromBytes(("scenario_" + background.getName() + testCase.getUri().toString().split("file:///")[1]).getBytes());
                testCaseMap.put("Scenario_uid", uuid.toString());
                testCaseMap.put("Scenario_unique_uid", UUID.randomUUID().toString());
                testCaseMap.put("Scenario_line", String.valueOf(background.getLocation().getLine()));
                testCaseMap.put("Scenario_type", "background");
                testCaseMap.put("Scenario_keyword", background.getKeyword());
                testCaseMap.put("Scenario_description", background.getDescription() != null ? background.getDescription() : "");
                testCaseMap.put("Scenario_start_timestamp", getDateTimeFromTimeStamp(event.getInstant()));
                return testCaseMap;
            }).orElseGet(HashMap::new);
        }
        return new HashMap<>();
    }

    private Map<String, String> createResultMapCsv(Result result, ThreadContext context) {
        Map<String, String> resultMap = new HashMap<>();
        String status = result.getStatus().name().toLowerCase(ROOT);

        // Update scenario and feature statuses based on step status
        if (status.equals(Constants.FAILED)) {
            context.scenarioStatus = Constants.FAILED;
            context.featureStatus = Constants.FAILED;
        } else if (status.equals(Constants.PASSED) && !context.scenarioStatus.equals(Constants.FAILED)) {
            context.scenarioStatus = Constants.PASSED;
            if (!context.featureStatus.equals(Constants.FAILED)) {
                context.featureStatus = Constants.PASSED;
            }
        }

        resultMap.put("Step_status", status);
        if (status.equals(Constants.PASSED) || status.equals(Constants.FAILED)) {
            resultMap.put("Step_name_transformed", getStepNameTransformed());
        }
        if (result.getError() != null) {
            resultMap.put("Step_error_message", printStackTrace(result.getError()));
        } else {
            resultMap.put("Step_error_message", "");
        }
        resultMap.put("Step_duration", String.valueOf(result.getDuration().toMillis()));
        return resultMap;
    }

    private String getDateTimeFromTimeStamp(Instant instant) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX")
                .withZone(ZoneOffset.UTC);
        return formatter.format(instant);
    }

    private String convertToCSV(String[] data) {
        return Stream.of(data)
                .map(this::escapeSpecialCharacters)
                .collect(Collectors.joining("|"));
    }

    private String escapeSpecialCharacters(String data) {
        if (data == null) {
            return "";
        }
        return data.replaceAll("\\R", " ").replace("|", "");
    }
}
